# Convex Architecture (Best‑Practice Example)

Lean, domain‑oriented layout for Convex apps. Copy this structure and keep files small and focused.

## Example File Tree
```
convex/
├─ schema.ts                 # Aggregate all domain tables
├─ http.ts                   # HTTP routes (webhooks, health checks)
├─ convex.config.ts          # Compose Convex components/middleware
├─ auth.ts                   # Auth provider setup (e.g., Password/OAuth)
├─ crons.ts                  # Optional scheduled tasks
├─ _shared/                  # Cross‑domain helpers (no business logic)
│  └─ auth.ts                # requireUser/requireAbility guards
├─ domains/
│  ├─ users/
│  │  ├─ schema.ts           # users tables + indexes
│  │  ├─ service.ts          # pure TS domain logic (no auth)
│  │  └─ api.ts              # query/mutation/action; validate + auth + delegate
│  └─ messages/
│     ├─ schema.ts
│     ├─ service.ts
│     ├─ api.ts
│     └─ workflows.ts        # Optional: actions/internal flows for external I/O
└─ _generated/               # Auto‑generated by Convex (do not edit)
   ├─ api.d.ts
   └─ server.d.ts
```

## File Responsibilities
- `schema.ts`: defineSchema; import and spread `domains/*/schema.ts` tables. No logic.
- `convex.config.ts`: `defineApp()` and `app.use(...)` to add components (e.g., Resend); keep side‑effect free.
- `http.ts`: `httpRouter()` + `httpAction` endpoints (webhooks/health). Thin layer that calls actions/mutations.
- `auth.ts`: configure providers with `convexAuth(...)`; export `auth`, `signIn`, etc.; optionally `auth.addHttpRoutes(router)`.
- `_shared/auth.ts`: tiny helpers like `requireUser(ctx)` and `requireAbility(ctx, action, subject)`.
- `domains/<feature>/schema.ts`: one file per domain with `defineTable(...).index(...)`.
- `domains/<feature>/service.ts`: pure functions operating on `ctx` (no auth, no validation). Reusable by multiple APIs.
- `domains/<feature>/api.ts`: the only exported Convex functions. Do input validation, auth, and delegate to `service`.
- `domains/<feature>/workflows.ts` (optional): `action` for external I/O; `internalMutation` for internal writes.
- `_generated/*`: type‑safe client/server bindings. Never edit.

## Patterns & Rules
- API boundary: validate args (`v.*`) and authorize first; keep `service` pure.
- Use `query` for reads, `mutation` for writes, `action` for external I/O/coordination, `internalMutation` for internal‑only writes.
- Index‑first: every list/query path should use a declared index; avoid full scans.
- Pagination by default: prefer `.paginate(...)` with `paginationOptsValidator` for list endpoints.
- Keep files focused: if a domain file exceeds ~300 lines or >6 exports, split logic into `service.ts` or new submodules.

## Add a New Feature (Quick)
1) Create `domains/<feature>/schema.ts` with tables and indexes. Import into root `schema.ts` and spread into `defineSchema(...)`.
2) Add `domains/<feature>/service.ts` for reusable domain logic.
3) Add `domains/<feature>/api.ts` exporting `query/mutation` (and `action` if needed). Validate inputs; enforce auth; delegate to `service`.
4) If doing external calls or long tasks, add `workflows.ts` with `action` and call `internalMutation` for writes.

This layout is intentionally minimal: clear boundaries, thin APIs, pure services, and schema aggregated at the root.
